[{"content":"这是一篇关于 leoay 技术日志的文章 ","description":"关于leoay tech 技术博客, leoay, 技术博客, 日志","id":0,"section":"","tags":null,"title":"关于","uri":"https://gitech.leoay.com/cn/about/"},{"content":"我是 leoay, 一个单纯的技术人，\n你好，我是 leoay，又好久不见了，好像上篇文章立的 flag 又被打破了， 如果不知道，那就前往上篇文章看看我立的 flag。\n果然， 同时更新维护两个公众号是一件不太容易的事情，熟悉我的朋友应该知道，我基本上都一值在 leoay 这个号更新，而且是日更，所以技术号有时候就会被忽略掉了，\n毕竟每天要和大部分人一样要工作。\n那么问题来了，什么是一个接口呢？\n在Go语言中，接口是一个方法的集合，当一个类型中定义了这个接口中的所有方法时，我们也将这叫做实现了这个接口。\n这个很像面向对象编程范式中提到的接口。\n接口指定了一个类型中拥有的方法，也决定了这个类型怎么去实现这些方法。\n举个例子，洗衣机可以被认为是一个有洗涤和干燥方法的接口，那么我们就可以把任何提供洗涤和干燥方法的类型，就叫做实现了洗衣机接口。\n下面我们用代码进行更加详细地说明：\n声明和实现一个接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  package main import ( \u0026#34;fmt\u0026#34; ) //interface definition type WashingMachine interface { Cleaning() (string, error) Drying() (string, error) } type MyWashingMachine string //MyWashingMachine 实现了 WashingMachine func (mwm MyWashingMachine) Cleaning() (string, error) { //do clean work \treturn \u0026#34;Clean Ok!\u0026#34;, nil } func (mwm MyWashingMachine) Drying() (string, error) { //do dry work \treturn \u0026#34;Drying Ok!\u0026#34;, nil } func main() { var v WashingMachine name := MyWashingMachine(\u0026#34;Leoay Home\u0026#34;) v = name resut, err := v.Cleaning() fmt.Println(\u0026#34;result: \u0026#34;, resut, \u0026#34;err is: \u0026#34;, err) resut, err = v.Drying() fmt.Println(\u0026#34;result: \u0026#34;, resut, \u0026#34;err is: \u0026#34;, err) }   在上面的代码中我们创建了一个 WashingMachine 接口类型，其中有两个方法，分别是 Cleaning ()和Drying()\n然后，我们定义了一个 MyWashingMachine 类型，接着我们写了两个方法分别是 Cleaning() 和 Drying(), 并将 MyWashingMachine 作为方法的接收类型\n这个时候，我们就可以说 MyWashingMachine 实现了 WashingMachine 接口。这个与 java 有很大不同，在java中我们一般使用 implements 这个关键字表示实现了一个接口。\n而在Go语言中，只需要这个类型包含接口中的所有方法即可。\n所以在下面的代码中，我们可以直接用 v 调用 Cleaning() 和 Drying() 这两个方法，因为 WashingMachine 已经实现了 WashingMachine 中的方法。\n到了一步，我们就创建了一个接口，怎么样，是不是超级简单。\n其实，如果你更深入学习 Go 语言时，你会发现接口在Go项目开发中使用的特别频繁，一不留神它就出现在你眼前，不过如果不了解的话，就会感到一头雾水。\n接口的使用实践 通过上面的例子，我们知道了怎么创建并实现一个接口，但是并没有真正说明白怎么在实际项目中使用。\n从上面代码中我们可以发现这一行代码 name := MyWashingMachine(\u0026quot;Leoay Home\u0026quot;)\n那么，这个有什么用呢？\n如果我们直接使用 name 调用 Cleaning() 和 Drying() 函数时，会出现什么问题呢？\n这个时候虽然也能正常输出，但是没有用到接口。\n下面，我就用一个实例说明一下接口的使用。\n我们将编写一个简单的程序，根据员工的个人工资计算公司的总费用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  package main import ( \u0026#34;fmt\u0026#34; ) type SalaryCalculator interface { CalculateSalary() int } type Permanent struct { empId int basicpay int pf int } type Contract struct { empId int basicpay int } //正式员工的工资是基本工资和奖金的总和 func (p Permanent) CalculateSalary() int { return p.basicpay + p.pf } //试用期员工的工资是单独的基本工资 func (c Contract) CalculateSalary() int { return c.basicpay } //总费用是通过迭代 SalaryCalculator 切片并求和来计算的 func totalExpense(s []SalaryCalculator) { expense := 0 for _, v := range s { expense = expense + v.CalculateSalary() } fmt.Printf(\u0026#34;每个月的总支出 ￥%d\u0026#34;, expense) } func main() { pemp1 := Permanent{ empId: 1, basicpay: 5000, pf: 20, } pemp2 := Permanent{ empId: 2, basicpay: 6000, pf: 30, } cemp1 := Contract{ empId: 3, basicpay: 3000, } employees := []SalaryCalculator{pemp1, pemp2, cemp1} totalExpense(employees) }   从上面的代码中我们可以看到 我们在 SalaryCalculator 接口中声明了一个 CalculateSalary() 方法\n在公司里有两种雇员，正式员工和试用期员工，分别用 Permanent 和 Contract 两个结构体表示，正式员工的工资包含基本工资和奖金，试用期员工的工资只有基本工资，但是我们希望只用一个方法计算员工的工资，所以我们就分别用 Permanent 和 Contract 实现了 SalaryCalculator 接口，这样无论员工是哪种类型，都有可以用 CalculateSalary 方法计算薪水了。\n然后我们定义了一个总的计算薪水支出的方法 totalExpense， 这个方法将 SalaryCalculator 切片作为参数，然后通过这个切片将所有的员工信息传到方法中去，然后在内部调用 CalculateSalary 方法计算每个员工的薪水并求和\n执行上面的代码我们可以最后的输出结果:\n每个月的总支出 ￥14050\n这样做的最大优点是 totalExpense 可以扩展到任何新员工类型而无需更改任何代码。\n假设公司增加了 Freelancer 一种工资结构不同的新型员工。\nFreelancer 可以只在 slice 参数中传递给 totalExpense 而无需对 totalExpense 函数进行任何一行代码更改\n这个方法会做它应该做的事情，Freelancer 也会实现 SalaryCalculator 接口\n下面我们就修改这个程序增加一种新的雇员 Freelancer， 其薪资是收入效率和总工作时间的乘积\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  package main import ( \u0026#34;fmt\u0026#34; ) type SalaryCalculator interface { CalculateSalary() int } type Permanent struct { empId int basicpay int pf int } type Contract struct { empId int basicpay int } type Freelancer struct { empId int ratePerHour int totalHours int } //正式员工的工资是基本工资和奖金的总和 func (p Permanent) CalculateSalary() int { return p.basicpay + p.pf } //试用期员工的工资是单独的基本工资 func (c Contract) CalculateSalary() int { return c.basicpay } //自由职业者的薪资 func (f Freelancer) CalculateSalary() int { return f.ratePerHour * f.totalHours } func totalExpense(s []SalaryCalculator) { expense := 0 for _, v := range s { expense = expense + v.CalculateSalary() } fmt.Printf(\u0026#34;每月的总支出 ￥%d\u0026#34;, expense) } func main() { pemp1 := Permanent{ empId: 1, basicpay: 5000, pf: 20, } pemp2 := Permanent{ empId: 2, basicpay: 6000, pf: 30, } cemp1 := Contract{ empId: 3, basicpay: 3000, } freelancer1 := Freelancer{ empId: 4, ratePerHour: 70, totalHours: 120, } freelancer2 := Freelancer{ empId: 5, ratePerHour: 100, totalHours: 100, } employees := []SalaryCalculator{pemp1, pemp2, cemp1, freelancer1, freelancer2} totalExpense(employees) }   我们添加了一个 Freelancer 结构体。并声明了一个用Freelancer实现的CalculateSalary方法。\n新的 totalExpense 方法中不需要更改其他代码， 因为 Freelancer 结构体也实现了该 SalaryCalculator 接口。\n然后我们在main方法中添加了几个 Freelancer 类型的员工。执行程序后打印，\n每月的总支出 ￥32450\n接口内部表示 可以认为接口在内部由 tuple(type, value) 中表示的。type 是接口的底层具体类型， value 保存具体类型的值。\n为了更好地理解，我们写一段代码展示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  package main import ( \u0026#34;fmt\u0026#34; ) type Worker interface { Work() } type Person struct { name string } func (p Person) Work() { fmt.Println(p.name, \u0026#34;is working\u0026#34;) } func describe(w Worker) { fmt.Printf(\u0026#34;Interface type %T value %v\\n\u0026#34;, w, w) } func main() { p := Person{ name: \u0026#34;Naveen\u0026#34;, } var w Worker = p describe(w) w.Work() }   从上面的代码我们可以看到，Worker 接口有一个方法 Work(), 而 Person 结构体类型实现了该接口。\n在main函数中我们定义了一个 Person 类型的 p, 并将他赋值给 Worker 类型的变量 w, 那么现在 w 的类型就变成了 Person, 而且其包含一个变量 name 值为 Naveen。\n而 describe 函数则打印了 Worker 接口的具体类型和值，结果输出：\n1  Interface type main.Person value {Naveen}   接下来我们更深入地了解一些怎么获取接口底层的值。\n空接口 一个没有方法的接口就是空接口， 用 interface{} 表示， 因为空接口中没有方法，所以所有的类型都实现了一个空接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import ( \u0026#34;fmt\u0026#34; ) func describe(i interface{}) { fmt.Printf(\u0026#34;Type = %T, value = %v\\n\u0026#34;, i, i) } func main() { s := \u0026#34;Hello World\u0026#34; describe(s) i := 55 describe(i) strt := struct { name string }{ name: \u0026#34;Naveen R\u0026#34;, } describe(strt) }   上面的代码中，因为函数 describe(i interface{}) 以一个空接口作为参数，所以任何类型的参数都可以被传入，这一点很像 C++ 或 Java 中的泛型。\nIn the program above, in line no.7, the describe(i interface{}) function takes an empty interface as an argument and hence any type can be passed.\n因此，在上面的示例代码中我们可以 describe 函数中传入字符串、整型和结构体，最后结果输出：\n1 2 3  Type = string, value = Hello World Type = int, value = 55 Type = struct { name string }, value = {Naveen R}   接口的类型断言 类型断言用于获取接口的底层值。\ni.(T) 用于获取 i 具体类型为 T 的接口的底层值。\n代码胜万言，下面我就用代码展示类型断言是怎么用的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import ( \u0026#34;fmt\u0026#34; ) func assert(i interface{}) { s := i.(int) //从 i 中获取 int 底层的值  fmt.Println(s) } func main() { var s interface{} = 56 assert(s) }   s 的实际类型是 int。我们使用 i.(int) 获取 i 底层的 int 的值\n那么如果上面的代码的实际类型不是 int，会出现什么呢？看下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import ( \u0026#34;fmt\u0026#34; ) func assert(i interface{}) { s := i.(int) fmt.Println(s) } func main() { var s interface{} = \u0026#34;Steven Paul\u0026#34; assert(s) }   上面的代码中，我们传入了一个字符串到 assert 函数中，想要从中获取一个整型的值，这段代码将会出现 panic，并打印如下信息：\n“interface {} is string, not int.”\n那么，现在该怎么办呢？怎么才能避免程序的崩溃呢？\n其实我们可以这样解决：\n因为 i.(T) 会返回一个 error 异常的，只要我们对它进行判断，就可以避免程序崩溃了，\nv, ok := i.(T)\n如果 i 的实际类型是 T, 那么 v 就是i的值，ok 就是 true, 代码正常运行；\n如果 i 的实际类型不是 T 的话，v 就返回空， ok就是 false, 代码也就不会崩溃了。\n所以我们对上面的代码进行简单的修改，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  package main import ( \u0026#34;fmt\u0026#34; ) func assert(i interface{}) { v, ok := i.(int) fmt.Println(v, ok) } func main() { var s interface{} = 56 assert(s) var i interface{} = \u0026#34;Steven Paul\u0026#34; assert(i) }   当 “Steven Paul” 传递给 assert 函数时，ok 将是 false ，因为 i 的具体类型不是 int，因此 v值为 0。所以该程序将输出：\n1 2  56 true 0 false   类型开关 类型开关用于将接口的实际类型与多种情况下 case 语句中指定的类型进行比较。\n类似于 switch case。唯一的区别是 case 指定的是类型而不是正常 switch 中的值。\n类型开关的语法类似于类型断言。\n在 i.(T) 类型断言的语法中，类型 T 应替换 type 为类型切换的关键字。\n下面看一下代码中是怎么实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  package main import ( \u0026#34;fmt\u0026#34; ) func findType(i interface{}) { switch i.(type) { case string: fmt.Printf(\u0026#34;I am a string and my value is %s\\n\u0026#34;, i.(string)) case int: fmt.Printf(\u0026#34;I am an int and my value is %d\\n\u0026#34;, i.(int)) default: fmt.Printf(\u0026#34;Unknown type\\n\u0026#34;) } } func main() { findType(\u0026#34;Naveen\u0026#34;) findType(77) findType(89.98) }   上面的代码中， switch i.(type) 指定了一个 a type switch， 每一个 case 语句将 i 的实际类型和指定类型比较。如果任何一个 case 匹配的话, 就打印出相应的语句。\n最后程序输出如下：\n1 2 3  I am a string and my value is Naveen I am an int and my value is 77 Unknown type   89.98 类型 是 float64，不匹配任何情况，因此最后一行打印 Unknown type。\n也可以将类型与接口进行比较。如果我们有一个类型并且该类型实现了一个接口，则可以将此类型与其实现的接口进行比较。\n为了更清楚，让我们编写一个程序详细说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  package main import \u0026#34;fmt\u0026#34; type Describer interface { Describe() } type Person struct { name string age int } func (p Person) Describe() { fmt.Printf(\u0026#34;%s is %d years old\u0026#34;, p.name, p.age) } func findType(i interface{}) { switch v := i.(type) { case Describer: v.Describe() default: fmt.Printf(\u0026#34;unknown type\\n\u0026#34;) } } func main() { findType(\u0026#34;Naveen\u0026#34;) p := Person{ name: \u0026#34;Naveen R\u0026#34;, age: 25, } findType(p) }   在上面的程序中，Person 结构体实现了 Describer 接口。 然后我们在 findType 函数中使用 case 语句比较类型 v 和比较 Describer 接口类型。\n而 p 是 Person类型，因此当我们把 p 传到 findType 中时，v 就是 Describer。\n所以最后程序输出如下：\n1 2  unknown type Naveen R is 25 years old   ","description":"go, interface, go语言, golang, 接口","id":1,"section":"posts","tags":["shortcode"],"title":"一文搞懂Go语言中的interface(1)","uri":"https://gitech.leoay.com/cn/posts/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84interface1/"}]